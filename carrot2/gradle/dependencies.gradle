allprojects {
  apply plugin: deps.plugins.dependencychecks.get().pluginId

  def consolidatedConfigurations = project.configurations.matching {
    it.name in [
      "annotationProcessor",
      "compileClasspath",
      "runtimeClasspath",
      "testCompileClasspath",
      "testRuntimeClasspath",
      "testFixturesClasspath",
      "langResources"
    ]
  }

  dependencyVersionChecks {
    lockFileComment = "An inventory of resolved dependency versions. Do not edit this file directly."
    configurationGroups {
      create("all", {
        include consolidatedConfigurations
      })
    }
  }

  dependencies {
    constraints {
      consolidatedConfigurations.configureEach { Configuration conf ->
        add(conf.name, deps.log4j.slf4j2, {
          because("Use consistent log4j version.")
        })
        add(conf.name, deps.log4j.core, {
          because("Use consistent log4j version.")
        })
        add(conf.name, deps.slf4j.api, {
          because("Use consistent slf4j version.")
        })
        add(conf.name, deps.junit, {
          because("Use consistent JUnit version.")
        })
      }
    }
  }
}

// Configure version catalog cleanups.
configure(rootProject) {
  apply plugin: deps.plugins.versionCatalogUpdate.get().pluginId

  versionCatalogUpdate {
    sortByKey = false
    keep {
      versions = [
        "node",
        "yarn",
        "carrot2"
      ]
    }

    versionCatalogs {
      deps {
        catalogFile = file("versions.toml")
      }
    }
  }

  tasks.matching { it.name == "tidy" }.configureEach {
    it.dependsOn(":versionCatalogFormatDeps")
  }

  tasks.matching {
    it.path in [
      ":versionCatalogUpdateDeps"
    ]
  }.configureEach {
    it.interactive = true
  }

  tasks.register("updateTomls", {
    group "Version catalog update"
    description "Update dependencies (saves update candidates to versions.updates.toml)"

    dependsOn ":versionCatalogUpdateDeps"
  })
}

// Configure dependency updates to not accept any odd versions.

def isNonStable = { String version ->
  def stableKeyword = [
    'RELEASE',
    'FINAL',
    'GA'
  ].any { it -> version.toUpperCase(Locale.ROOT).contains(it) }
  def regex = /^[0-9,.v-]+(-r)?$/
  return !stableKeyword && !(version ==~ regex)
}

tasks.named("dependencyUpdates").configure {
  rejectVersionIf {
    isNonStable(it.candidate.version)
  }
}
